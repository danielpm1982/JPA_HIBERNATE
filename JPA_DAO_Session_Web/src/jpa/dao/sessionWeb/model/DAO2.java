package jpa.dao.sessionWeb.model;
import java.util.List;
import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Query;
import javax.persistence.TypedQuery;

//The same as DAO but using EntityManager instead of Session. All servlets must be adjusted!
//DAO uses SessionFactory and DAO2 uses EntityManagerFactory. Both work pretty fine. The xml for both when used at JEE projects is the src/hibernate.cfg.xml. For using persistence.xml for DAO2 here, more complex structures like jars and war files would have to be used with this .xml file within. Instead, the hibernate.cfg.xml conf file of DAO (Session) also works for DAO2 (EntityManager), and can be more easily found. For Console apps, on the other hand, the API can find persistence.xml if put inside src/META-INF folder, and that's whats used for DAO. The API also finds the src/hibernate.cfg.xml as well, when using DAO2.

public class DAO2 {
	public static boolean insertStudent(Student student, EntityManagerFactory factory) { //inserts a Student and turn it managed, setting its id property with the id value generated by the dbsm. Retrieves true if saving succeeds, or false, if not.
		EntityManager em = factory.createEntityManager();
		try {
			em.getTransaction().begin();
			em.persist(student);
			em.getTransaction().commit();
			return true;
		} catch (Exception e) {
			e.printStackTrace(System.out);
			return false;
		} finally {
			em.close();
		}
	}
	public static Student searchStudent(Long studentId, EntityManagerFactory factory) { //search a Student from a Long id argument, retrieving a managed Student object reference if that id exists, or null, if not.
		EntityManager em = factory.createEntityManager();
		try {
			em.getTransaction().begin();
			Student student = em.find(Student.class, studentId);
			em.getTransaction().commit();
			return student;
		} catch (Exception e) {
			e.printStackTrace(System.out);
			return null;
		} finally {
			em.close();
		}
	}
	public static List<Student> searchStudents(String studentName, EntityManagerFactory factory) { //search all students that have partially or totally the argument name. 
		EntityManager em = factory.createEntityManager();
		try {
			em.getTransaction().begin();
			TypedQuery<Student> query = em.createQuery("from Student where name like '%"+studentName+"%'", Student.class);
			List<Student> studentList = query.getResultList();
			em.getTransaction().commit();
			return studentList;
		} catch (Exception e) {
			e.printStackTrace(System.out);
			return null;
		} finally {
			em.close();
		}
	}
	public static List<Student> searchAllStudents(EntityManagerFactory factory) { //search all students. 
		EntityManager em = factory.createEntityManager();
		try {
			em.getTransaction().begin();
			TypedQuery<Student> query = em.createQuery("from Student", Student.class);
			List<Student> studentList = query.getResultList();
			em.getTransaction().commit();
			return studentList;
		} catch (Exception e) {
			e.printStackTrace(System.out);
			return null;
		} finally {
			em.close();
		}
	}
	public static boolean updateStudent(Student oldStudent, Student newStudent, EntityManagerFactory factory) { // takes two mock student objects, searches for the first in the DB and, if the id exists, retrieves the actual object for being updated with the values of the other mock object (except the id attribute, which must keep the same). During the committing process of the managed actual object, and after it is updated through its sets, it is also automatically saved (or persisted) at the session and at the DB.
		oldStudent = DAO2.searchStudent(oldStudent.getId(), factory);
		if(oldStudent!=null) {
			EntityManager em = factory.createEntityManager();
			try {
				em.getTransaction().begin();
				oldStudent = em.merge(oldStudent);
				oldStudent.setName(newStudent.getName());
				em.getTransaction().commit();
				return true;
			} catch (Exception e) {
				e.printStackTrace(System.out);
				return false;
			} finally {
				em.close();
			}
		} else {
			return false;
		}
	}
	public static int updateStudentBulk(String studentName, String newNameForAllThatMatches, EntityManagerFactory factory) { //bulk update of ALL students that match partially or exactly the argument studentName with a new name, identical to all of them.
		if(studentName!=null) {
			EntityManager em = factory.createEntityManager();
			try {
				em.getTransaction().begin();
				Query studentQueryToUpdate = em.createQuery("update Student set name='"+newNameForAllThatMatches+"' where name like '%"+studentName+"%'");
				int affectedRows = studentQueryToUpdate.executeUpdate();
				em.getTransaction().commit();
				return affectedRows;
			} catch (Exception e) {
				e.printStackTrace(System.out);
				return 0;
			} finally {
				em.close();
			}
		} else {
			return 0;
		}
	}
	public static boolean deleteStudent(Long studentId, EntityManagerFactory factory) { //from a Long id argument, search for a Student and, if found, delete it. Returns true if successful, or false, if not.
		Student student = searchStudent(studentId, factory); //a not null result here guarantees the student exists, and retrieves it in the managed state.
		if(student!=null) {
			EntityManager em = factory.createEntityManager();
			try {
				em.getTransaction().begin();
				student=em.merge(student);
				em.remove(student);
				em.getTransaction().commit();
				return true;
			} catch (Exception e) {
				e.printStackTrace(System.out);
				return false;
			} finally {
				em.close();
			}
		} else {
			return false;
		}
	}
	public static boolean deleteStudent(Student student, EntityManagerFactory factory) { //if the Student reference passed as argument exists in the DB (actually, its id, regardless of other attributes values), whether or not in the managed state, delete it. Returns true if successful, or false, if not. If delete is called on a non-existing instance id, Exceptions are thrown.
		if(student!=null&&searchStudent(student.getId(),factory)!=null) {
			EntityManager em = factory.createEntityManager();
			try {
				em.getTransaction().begin();
				student=em.merge(student);
				em.remove(student);
				em.getTransaction().commit();
				return true;
			} catch (Exception e) {
				e.printStackTrace(System.out);
				return false;
			} finally {
				em.close();
			}
		} else {
			return false;
		}
		
//		or refactor to:
//		return deleteStudent(student.getId(), factory);
	}
	public static boolean deleteStudentBulk(String studentName, EntityManagerFactory factory) { //bulk deletion of ALL students that match partially or exactly the argument studentName.
		if(studentName!=null) {
			EntityManager em = factory.createEntityManager();
			try {
				em.getTransaction().begin();
				Query studentListToDelete = em.createQuery("delete Student where name like '%"+studentName+"%'");
				studentListToDelete.executeUpdate();
				em.getTransaction().commit();
				return true;
			} catch (Exception e) {
				e.printStackTrace(System.out);
				return false;
			} finally {
				em.close();
			}
		} else {
			return false;
		}
	}
	public static boolean truncateDBTable(String fullyQualifiedTableName, EntityManagerFactory factory) { //truncate the argument name table, for resetting the id generatedValue counting and eliminating all table rows.
		if(fullyQualifiedTableName!=null) {
			EntityManager em = factory.createEntityManager();
			try {
				em.getTransaction().begin();
				em.createNativeQuery("truncate table "+fullyQualifiedTableName).executeUpdate();
				em.getTransaction().commit();
				return true;
			} catch (Exception e) {
				e.printStackTrace(System.out);
				return false;
			} finally {
				em.close();
			}
		} else {
			return false;
		}
	}
}
